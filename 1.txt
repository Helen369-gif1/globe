<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Живой глобус с контуром материков</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at center, #050510 0%, #000000 100%);
    overflow: hidden;
    cursor: grab;
    user-select: none;
  }
  canvas { display: block; background: transparent !important; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/topojson@3"></script>

<script>
/* === НАСТРОЙКИ === */
const PARTICLE_COUNT = 4000;
const RADIUS = 5.0;
const BASE_SPEED = 0.001;
const RETURN_FORCE = 0.01;
const MOUSE_FORCE = 0.025;
const DAMPING = 0.9;
const JITTER_STRENGTH = 0.02;

/* === СЦЕНА === */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.z = 12;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setClearColor(0x000000, 0);
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* === ГЛОБУСНАЯ СЕТКА === */
const gridGeometry = new THREE.SphereGeometry(RADIUS, 36, 18);
const gridMaterial = new THREE.LineBasicMaterial({
  color: 0x00aaff,
  transparent: true,
  opacity: 0.15,
  linewidth: 0.3
});
const grid = new THREE.LineSegments(new THREE.WireframeGeometry(gridGeometry), gridMaterial);
scene.add(grid);

/* === КОНТУРЫ МАТЕРИКОВ === */
let continents = new THREE.Group(); // группа для материков
scene.add(continents);

fetch("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json")
  .then(res => res.json())
  .then(world => {
    const geoJson = topojson.feature(world, world.objects.countries);

    geoJson.features.forEach(feature => {
      const coordinates = feature.geometry.coordinates;

      coordinates.forEach(polygon => {
        // в случае MultiPolygon
        let polys = feature.geometry.type === "MultiPolygon" ? polygon : [polygon];

        polys.forEach(ring => {
          const points = [];
          ring[0].forEach(coord => {
            const lon = coord[0] * Math.PI / 180;
            const lat = coord[1] * Math.PI / 180;
            const x = (RADIUS + 0.01) * Math.cos(lat) * Math.cos(lon);
            const y = (RADIUS + 0.01) * Math.sin(lat);
            const z = (RADIUS + 0.01) * Math.cos(lat) * Math.sin(lon);
            points.push(new THREE.Vector3(x, y, z));
          });
          const geometry = new THREE.BufferGeometry().setFromPoints(points);
          const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({
            color: 0xffffff,
            opacity: 0.8,
            transparent: true
          }));
          continents.add(line);
        });
      });
    });
  });

/* === ЧАСТИЦЫ === */
const positions = new Float32Array(PARTICLE_COUNT * 3);
const basePositions = new Float32Array(PARTICLE_COUNT * 3);
const velocities = new Float32Array(PARTICLE_COUNT * 3);

for (let i = 0; i < PARTICLE_COUNT; i++) {
  const r = RADIUS * Math.cbrt(Math.random());
  const theta = Math.acos(2 * Math.random() - 1);
  const phi = Math.random() * 2 * Math.PI;
  const x = r * Math.sin(theta) * Math.cos(phi);
  const y = r * Math.sin(theta) * Math.sin(phi);
  const z = r * Math.cos(theta);
  positions.set([x, y, z], i * 3);
  basePositions.set([x, y, z], i * 3);
  velocities.set([(Math.random() - 0.5) * BASE_SPEED, (Math.random() - 0.5) * BASE_SPEED, (Math.random() - 0.5) * BASE_SPEED], i * 3);
}

const geometry = new THREE.BufferGeometry();
geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
const particleMaterial = new THREE.PointsMaterial({
  color: 0x00ffff,
  size: 0.045,
  transparent: true,
  opacity: 0.9,
  blending: THREE.AdditiveBlending,
});
const points = new THREE.Points(geometry, particleMaterial);
scene.add(points);

/* === МЫШЬ === */
let mouse = new THREE.Vector2();
let mouseWorld = new THREE.Vector3();
const raycaster = new THREE.Raycaster();
const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

document.addEventListener("mousemove", (e) => {
  mouse.x = (e.clientX / innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / innerHeight) * 2 + 1;
});

/* === АНИМАЦИЯ === */
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();

  raycaster.setFromCamera(mouse, camera);
  raycaster.ray.intersectPlane(plane, mouseWorld);

  grid.rotation.y += 0.001;
  points.rotation.y += 0.0012;
  continents.rotation.y = grid.rotation.y; // материки вращаются вместе с глобусом

  for (let i = 0; i < PARTICLE_COUNT; i++) {
    const idx = i * 3;
    const pos = new THREE.Vector3(positions[idx], positions[idx+1], positions[idx+2]);
    const base = new THREE.Vector3(basePositions[idx], basePositions[idx+1], basePositions[idx+2]);

    const jitter = new THREE.Vector3(
      Math.sin(t * 1.5 + i * 0.73) * JITTER_STRENGTH,
      Math.cos(t * 1.3 + i * 0.61) * JITTER_STRENGTH,
      Math.sin(t * 1.7 + i * 0.49) * JITTER_STRENGTH
    );
    pos.add(jitter.multiplyScalar(0.25));

    const dirToMouse = mouseWorld.clone().sub(pos);
    const dist = dirToMouse.length();

    if (dist < RADIUS * 1.5) {
      const strength = (1 - dist / (RADIUS * 1.5)) * MOUSE_FORCE;
      const tangent = new THREE.Vector3(-dirToMouse.y, dirToMouse.x, dirToMouse.z).normalize();
      const combined = dirToMouse.normalize().multiplyScalar(strength * 0.6)
        .add(tangent.multiplyScalar(strength * 0.4));

      velocities[idx] += combined.x;
      velocities[idx+1] += combined.y;
      velocities[idx+2] += combined.z;
    }

    const toBase = base.clone().sub(pos).multiplyScalar(RETURN_FORCE);
    velocities[idx] += toBase.x;
    velocities[idx+1] += toBase.y;
    velocities[idx+2] += toBase.z;

    velocities[idx] *= DAMPING;
    velocities[idx+1] *= DAMPING;
    velocities[idx+2] *= DAMPING;

    positions[idx] += velocities[idx];
    positions[idx+1] += velocities[idx+1];
    positions[idx+2] += velocities[idx+2];
  }

  geometry.attributes.position.needsUpdate = true;
  renderer.render(scene, camera);
}
animate();

/* === РАЗМЕР === */
window.addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
