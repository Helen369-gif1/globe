<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Живой глобус с контуром материков</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at center, #050510 0%, #000000 100%);
    overflow: hidden;
    cursor: grab;
    user-select: none;
  }
  canvas { display: block; background: transparent !important; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/topojson@3"></script>
<script src="https://cdn.jsdelivr.net/npm/three-geojson-geometry@1.2.0/dist/three-geojson-geometry.min.js"></script>

<script>
/* === НАСТРОЙКИ === */
const PARTICLE_COUNT = 4000;
const RADIUS = 5.0;
const BASE_SPEED = 0.001;
const RETURN_FORCE = 0.01;
const MOUSE_FORCE = 0.025;
const DAMPING = 0.9;
const JITTER_STRENGTH = 0.02;

/* === СЦЕНА === */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.z = 12;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setClearColor(0x000000, 0);
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* === ГЛОБУСНАЯ СЕТКА === */
const gridGeometry = new THREE.SphereGeometry(RADIUS, 36, 18);
const gridMaterial = new THREE.LineBasicMaterial({
  color: 0x00aaff,
  transparent: true,
  opacity: 0.15,
  linewidth: 0.3
});
const grid = new THREE.LineSegments(new THREE.WireframeGeometry(gridGeometry), gridMaterial);
scene.add(grid);

/* === КОНТУРЫ МАТЕРИКОВ === */
let continents; // глобальная переменная для вращения вместе с grid
fetch("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json")
  .then(res => res.json())
  .then(world => {
    const geoJson = topojson.feature(world, world.objects.countries);
    const geom = new THREE.GeoJsonGeometry(geoJson, RADIUS + 0.01);
    const material = new THREE.LineBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.8,
      linewidth: 1.2
    });
    continents = new THREE.LineSegments(geom, material);
    continents.rotation.y = Math.PI; // выравнивание
    scene.add(continents); // добавляем в сцену
  });

/* === ЧАСТИЦЫ === */
const positions = new Float32Array(PARTICLE_COUNT * 3);
const basePositions = new Float32Array(PARTICLE_COUNT * 3);
const velocities = new Float32Array(PARTICLE_COUNT * 3);

for (let i = 0; i < PARTICLE_COUNT; i++) {
  const r = RADIUS * Math.cbrt(Math.random());
  const theta = Math.acos(2 * Math.random() - 1);
  const phi = Math.random() * 2 * Math.PI;
  const x = r * Math.sin(theta) * Math.cos(phi);
  const y = r * Math.sin(theta) * Math.sin(phi);
  const z = r * Math.cos(theta);
  positions.set([x, y, z], i * 3);
  basePositions.set([x, y, z], i * 3);
  velocities.set([(Math.random() - 0.5) * BASE_SPEED, (Math.random() - 0.5) * BASE_SPEED, (Math.random() - 0.5) * BASE_SPEED], i * 3);
}

const geometry = new THREE.BufferGeometry();
geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
const material = new THREE.PointsMaterial({
  color: 0x00ffff,
  size: 0.045,
  transparent: true,
  opacity: 0.9,
  blending: THREE.AdditiveBlending,
});
const points = new THREE.Points(geometry, material);
scene.add(points);

/* === МЫШЬ === */
let mouse = new THREE.Vector2();
let mouseWorld = new THREE.Vector3();
const raycaster = new THREE.Raycaster();
const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

document.addEventListener("mousemove", (e) => {
  mouse.x = (e.clientX / innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / innerHeight) * 2 + 1;
});

/* === АНИМАЦИЯ === */
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();

  raycaster.setFromCamera(mouse, camera);
  raycaster.ray.intersectPlane(plane, mouseWorld);

  grid.rotation.y += 0.001;
  points.rotation.y += 0.0012;

  if (continents) continents.rotation.y = grid.rotation.y; // материки вращаются вместе с глобусом

  for (let i = 0; i < PARTICLE_COUNT; i++) {
    const idx = i * 3;
    const pos = new THREE.Vector3(positions[idx], positions[idx+1], positions[idx+2]);
    const base = new THREE.Vector3(basePositions[idx], basePositions[idx+1], basePositions[idx+2]);

    const jitter = new THREE.Vector3(
      Math.sin(t * 1.5 + i * 0.73) * JITTER_STRENGTH,
      Math.cos(t * 1.3 + i * 0.61) * JITTER_STRENGTH,
      Math.sin(t * 1.7 + i * 0.49) * JITTER_STRENGTH
    );
    pos.add(jitter.multiplyScalar(0.25));

    const dirToMouse = mouseWorld.clone().sub(pos);
    const dist = dirToMouse.length();

    if (dist < RADIUS * 1.5) {
      const strength = (1 - dist / (RADIUS * 1.5)) * MOUSE_FORCE;
      const tangent = new THREE.Vector3(-dirToMouse.y, dirToMouse.x, dirToMouse.z).normalize();
      const combined = dirToMouse.normalize().multiplyScalar(strength * 0.6)
        .add(tangent.multiplyScalar(strength * 0.4));

      velocities[idx] += combined.x;
      velocities[idx+1] += combined.y;
      velocities[idx+2] += combined.z;
    }

    const toBase = base.clone().sub(pos).multiplyScalar(RETURN_FORCE);
    velocities[idx] += toBase.x;
    velocities[idx+1] += toBase.y;
    velocities[idx+2] += toBase.z;

    velocities[idx] *= DAMPING;
    velocities[idx+1] *= DAMPING;
    velocities[idx+2] *= DAMPING;

    positions[idx] += velocities[idx];
    positions[idx+1] += velocities[idx+1];
    positions[idx+2] += velocities[idx+2];
  }

  geometry.attributes.position.needsUpdate = true;
  renderer.render(scene, camera);
}
animate();

/* === РАЗМЕР === */
window.addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
