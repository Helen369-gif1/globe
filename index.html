<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Живой глобус с материками и частицами</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    background: transparent; /* полностью прозрачный фон страницы */
    overflow: hidden;
    cursor: grab;
    user-select: none;
  }
  canvas { display: block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>

<script>
/* === НАСТРОЙКИ === */
const PARTICLE_COUNT = 4000;
const RADIUS = 5.0;
const BASE_SPEED = 0.001;
const RETURN_FORCE = 0.01;
const MOUSE_FORCE = 0.025;
const DAMPING = 0.9;
const JITTER_STRENGTH = 0.02;

/* === СЦЕНА === */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.z = 12;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* === МЯГКОЕ СВЕЧЕНИЕ ГЛОБУСА === */
const glowGeometry = new THREE.SphereGeometry(RADIUS * 1.02, 64, 32);
const glowMaterial = new THREE.ShaderMaterial({
  uniforms: {
    color1: { value: new THREE.Color(0x001020) },
    color2: { value: new THREE.Color(0x000000) }
  },
  vertexShader: `
    varying vec3 vNormal;
    void main() {
      vNormal = normalize(normalMatrix * normal);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    varying vec3 vNormal;
    uniform vec3 color1;
    uniform vec3 color2;
    void main() {
      float intensity = pow(0.6 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
      gl_FragColor = vec4(mix(color1, color2, intensity), 0.7);
    }
  `,
  transparent: true,
  side: THREE.DoubleSide
});
const glow = new THREE.Mesh(glowGeometry, glowMaterial);
scene.add(glow);

/* === СЕТКА ГЛОБУСА === */
const gridGeometry = new THREE.SphereGeometry(RADIUS, 72, 36);
const gridMaterial = new THREE.LineBasicMaterial({
  color: 0x00aaff,
  transparent: true,
  opacity: 0.15,
  linewidth: 0.3
});
const grid = new THREE.LineSegments(new THREE.WireframeGeometry(gridGeometry), gridMaterial);
scene.add(grid);

/* === КОНТУРЫ МАТЕРИКОВ === */
const continentsData = [
  { lon: [-17,-10,10,20,35,50,35,20,10,-10,-17,50,47], lat: [37,30,20,10,0,-10,-20,-25,-20,-10,37,-25,-20] },
  { lon: [-80,-70,-60,-50,-40,-35,-30,-35,-50,-70,-80,-60,-50], lat: [12,0,-10,-20,-25,-30,-40,-50,-55,-20,12,-5,5] },
  { lon: [-170,-150,-120,-100,-80,-60,-50,-40,-60,-80,-100,-150,-170,-50,-40,-30], lat: [70,65,50,45,40,45,50,55,60,65,70,75,70,80,78,75] },
  { lon: [-10,20,40,60,80,100,120,140,160,180,170,150,130,100,60,30,0,-10,140,142,145], lat: [35,40,50,55,60,50,45,50,60,70,65,60,55,50,45,40,40,35,36,38,35] },
  { lon: [110,120,135,150,145,130,115,110,145,148], lat: [-10,-20,-30,-25,-35,-40,-25,-10,-42,-43] },
  { lon: [-180,-150,-120,-90,-60,-30,0,30,60,90,120,150,180], lat: [-60,-65,-70,-75,-70,-65,-60,-65,-70,-75,-70,-65,-60] }
];
const toRad = deg => deg * Math.PI / 180;
const lineMaterial = new THREE.LineBasicMaterial({
  color: 0x00ccff,
  linewidth: 1.5,
  transparent: true,
  opacity: 0.8
});
continentsData.forEach(cont => {
  const points = [];
  for (let i = 0; i < cont.lon.length; i++) {
    const phi = toRad(90 - cont.lat[i]);
    const theta = toRad(cont.lon[i] + 180);
    const x = -RADIUS * Math.sin(phi) * Math.cos(theta);
    const y = RADIUS * Math.cos(phi);
    const z = RADIUS * Math.sin(phi) * Math.sin(theta);
    points.push(new THREE.Vector3(x, y, z));
  }
  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const line = new THREE.Line(geometry, lineMaterial);
  scene.add(line);
});

/* === ЧАСТИЦЫ === */
const positions = new Float32Array(PARTICLE_COUNT * 3);
const basePositions = new Float32Array(PARTICLE_COUNT * 3);
const velocities = new Float32Array(PARTICLE_COUNT * 3);

for (let i = 0; i < PARTICLE_COUNT; i++) {
  const r = RADIUS * Math.cbrt(Math.random());
  const theta = Math.acos(2 * Math.random() - 1);
  const phi = Math.random() * 2 * Math.PI;
  const x = r * Math.sin(theta) * Math.cos(phi);
  const y = r * Math.sin(theta) * Math.sin(phi);
  const z = r * Math.cos(theta);
  positions.set([x, y, z], i * 3);
  basePositions.set([x, y, z], i * 3);
  velocities.set([(Math.random() - 0.5) * BASE_SPEED, (Math.random() - 0.5) * BASE_SPEED, (Math.random() - 0.5) * BASE_SPEED], i * 3);
}

const geometry = new THREE.BufferGeometry();
geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
const material = new THREE.PointsMaterial({
  color: 0x00ffff,
  size: 0.045,
  transparent: true,
  opacity: 0.9,
  blending: THREE.AdditiveBlending,
});
const points = new THREE.Points(geometry, material);
scene.add(points);

/* === МЫШЬ === */
let mouse = new THREE.Vector2();
let mouseWorld = new THREE.Vector3();
const raycaster = new THREE.Raycaster();
const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

document.addEventListener("mousemove", (e) => {
  mouse.x = (e.clientX / innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / innerHeight) * 2 + 1;
});

/* === АНИМАЦИЯ === */
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();

  raycaster.setFromCamera(mouse, camera);
  raycaster.ray.intersectPlane(plane, mouseWorld);

  glow.rotation.y += 0.001;
  grid.rotation.y += 0.001;
  scene.children.forEach(obj => {
    if (obj.type === 'Line') obj.rotation.y += 0.001;
  });
  points.rotation.y += 0.0012;

  for (let i = 0; i < PARTICLE_COUNT; i++) {
    const idx = i * 3;
    const pos = new THREE.Vector3(positions[idx], positions[idx+1], positions[idx+2]);
    const base = new THREE.Vector3(basePositions[idx], basePositions[idx+1], basePositions[idx+2]);

    const jitter = new THREE.Vector3(
      Math.sin(t * 1.5 + i * 0.73) * JITTER_STRENGTH,
      Math.cos(t * 1.3 + i * 0.61) * JITTER_STRENGTH,
      Math.sin(t * 1.7 + i * 0.49) * JITTER_STRENGTH
    );
    pos.add(jitter.multiplyScalar(0.25));

    const dirToMouse = mouseWorld.clone().sub(pos);
    const dist = dirToMouse.length();

    if (dist < RADIUS * 1.5) {
      const strength = (1 - dist / (RADIUS * 1.5)) * MOUSE_FORCE;
      const tangent = new THREE.Vector3(-dirToMouse.y, dirToMouse.x, dirToMouse.z).normalize();
      const combined = dirToMouse.normalize().multiplyScalar(strength * 0.6)
        .add(tangent.multiplyScalar(strength * 0.4));
      velocities[idx] += combined.x;
      velocities[idx+1] += combined.y;
      velocities[idx+2] += combined.z;
    }

    const toBase = base.clone().sub(pos).multiplyScalar(RETURN_FORCE);
    velocities[idx] += toBase.x;
    velocities[idx+1] += toBase.y;
    velocities[idx+2] += toBase.z;

    velocities[idx] *= DAMPING;
    velocities[idx+1] *= DAMPING;
    velocities[idx+2] *= DAMPING;

    positions[idx] += velocities[idx];
    positions[idx+1] += velocities[idx+1];
    positions[idx+2] += velocities[idx+2];
  }

  geometry.attributes.position.needsUpdate = true;
  renderer.render(scene, camera);
}
animate();

/* === АДАПТАЦИЯ === */
window.addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
