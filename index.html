я э<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Живой глобус с материками и частицами</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at center, #050510 0%, #000000 100%);
    overflow: hidden;
    cursor: grab;
    user-select: none;
  }
  canvas { display: block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script>
/* === НАСТРОЙКИ === */
const PARTICLE_COUNT = 2000;   // уменьшено, чтобы быстрее реагировали
const RADIUS = 5.0;
const BASE_SPEED = 0.001;
const RETURN_FORCE = 0.01;
const MOUSE_FORCE = 0.05;      // увеличена сила реакции на курсор
const DAMPING = 0.9;
const JITTER_STRENGTH = 0.0;   // убираем джиттер на старте, чтобы частицы сразу появились


/* === СЦЕНА === */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.z = 12;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* === ГЛОБУС + КОНТУРЫ В КАЧЕСТВЕ ТЕКСТУРЫ === */
const textureLoader = new THREE.TextureLoader();
const contourTexture = textureLoader.load('map_contour.png');  // файл с картографическим контуром

const sphereGeo = new THREE.SphereGeometry(RADIUS, 72, 36);
const sphereMat = new THREE.MeshBasicMaterial({
  map: contourTexture,
  transparent: true,
  opacity: 0.8,
  side: THREE.DoubleSide
});
const sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);
scene.add(sphereMesh);

/* === СЕТКА (wireframe) поверх сферы === */
const gridGeometry = new THREE.SphereGeometry(RADIUS, 48, 24);
const gridMaterial = new THREE.LineBasicMaterial({
  color: 0x00aaff,
  transparent: true,
  opacity: 0.2,
  linewidth: 0.3
});
const grid = new THREE.LineSegments(new THREE.WireframeGeometry(gridGeometry), gridMaterial);
scene.add(grid);

/* === ЧАСТИЦЫ ВНУТРИ СФЕРЫ === */
const positions = new Float32Array(PARTICLE_COUNT * 3);
const basePositions = new Float32Array(PARTICLE_COUNT * 3);
const velocities = new Float32Array(PARTICLE_COUNT * 3);

for (let i = 0; i < PARTICLE_COUNT; i++) {
  const r = RADIUS * Math.cbrt(Math.random());
  const theta = Math.acos(2 * Math.random() - 1);
  const phi = Math.random() * 2 * Math.PI;
  const x = r * Math.sin(theta) * Math.cos(phi);
  const y = r * Math.sin(theta) * Math.sin(phi);
  const z = r * Math.cos(theta);
  positions.set([x, y, z], i * 3);
  basePositions.set([x, y, z], i * 3);
  velocities.set([0, 0, 0], i * 3); // скорость сразу 0, частицы не “разбегаются”
}

const partGeo = new THREE.BufferGeometry();
partGeo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
const partMat = new THREE.PointsMaterial({
  color: 0x00ffff,
  size: 0.045,
  transparent: true,
  opacity: 0.9,
  blending: THREE.AdditiveBlending
});
const points = new THREE.Points(partGeo, partMat);
scene.add(points);

/* === МЫШЬ === */
let mouse = new THREE.Vector2();
let mouseWorld = new THREE.Vector3();
const raycaster = new THREE.Raycaster();
const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

document.addEventListener("mousemove", (e) => {
  mouse.x = (e.clientX / innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / innerHeight) * 2 + 1;
});

/* === АНИМАЦИЯ === */
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();

  raycaster.setFromCamera(mouse, camera);
  raycaster.ray.intersectPlane(plane, mouseWorld);

  sphereMesh.rotation.y += 0.001;
  grid.rotation.y += 0.001;
  points.rotation.y += 0.0012;

  for (let i = 0; i < PARTICLE_COUNT; i++) {
    const idx = i * 3;
    const pos = new THREE.Vector3(positions[idx], positions[idx + 1], positions[idx + 2]);
    const base = new THREE.Vector3(basePositions[idx], basePositions[idx + 1], basePositions[idx + 2]);

    const jitter = new THREE.Vector3(
      Math.sin(t * 1.5 + i * 0.73) * JITTER_STRENGTH,
      Math.cos(t * 1.3 + i * 0.61) * JITTER_STRENGTH,
      Math.sin(t * 1.7 + i * 0.49) * JITTER_STRENGTH
    );
    pos.add(jitter.multiplyScalar(0.25));

    const dirToMouse = mouseWorld.clone().sub(pos);
    const dist = dirToMouse.length();

    if (dist < RADIUS * 1.5) {
      const strength = (1 - dist / (RADIUS * 1.5)) * MOUSE_FORCE;
      const tangent = new THREE.Vector3(-dirToMouse.y, dirToMouse.x, dirToMouse.z).normalize();
      const combined = dirToMouse.normalize().multiplyScalar(strength * 0.6)
        .add(tangent.multiplyScalar(strength * 0.4));
      velocities[idx] += combined.x;
      velocities[idx + 1] += combined.y;
      velocities[idx + 2] += combined.z;
    }

    const toBase = base.clone().sub(pos).multiplyScalar(RETURN_FORCE);
    velocities[idx] += toBase.x;
    velocities[idx + 1] += toBase.y;
    velocities[idx + 2] += toBase.z;

    velocities[idx] *= DAMPING;
    velocities[idx + 1] *= DAMPING;
    velocities[idx + 2] *= DAMPING;

    positions[idx] += velocities[idx];
    positions[idx + 1] += velocities[idx + 1];
    positions[idx + 2] += velocities[idx + 2];
  }

  partGeo.attributes.position.needsUpdate = true;
  renderer.render(scene, camera);
}
animate();

/* === АДАПТАЦИЯ === */
window.addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
