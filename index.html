<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Живой глобус с материками и частицами</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at center, #050510 0%, #000000 100%);
    overflow: hidden;
    cursor: grab;
    user-select: none;
  }
  canvas { display: block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script>
/* === НАСТРОЙКИ === */
const PARTICLE_COUNT = 2000; // оптимально для мгновенной реакции
const RADIUS = 5.0;
const BASE_SPEED = 0.001;
const RETURN_FORCE = 0.02;
const MOUSE_FORCE = 0.05;
const DAMPING = 0.85;
const JITTER_STRENGTH = 0.002;

/* === СЦЕНА === */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.z = 12;

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* === СПЛОШНАЯ СЕТКА === */
const gridGeo = new THREE.SphereGeometry(RADIUS, 64, 32);
const gridMat = new THREE.LineBasicMaterial({ color:0x00aaff, transparent:true, opacity:0.2 });
const grid = new THREE.LineSegments(new THREE.WireframeGeometry(gridGeo), gridMat);
scene.add(grid);

/* === СФЕРА С МАТЕРИКАМИ === */
const textureLoader = new THREE.TextureLoader();
const earthTex = textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/8/80/World_map_-_yellow_contour.png');

const earthGeo = new THREE.SphereGeometry(RADIUS, 64, 32);
const earthMat = new THREE.MeshBasicMaterial({ map: earthTex, transparent:false, opacity:1 });
const earth = new THREE.Mesh(earthGeo, earthMat);
scene.add(earth);

/* === ЧАСТИЦЫ === */
const positions = new Float32Array(PARTICLE_COUNT*3);
const basePositions = new Float32Array(PARTICLE_COUNT*3);
const velocities = new Float32Array(PARTICLE_COUNT*3);

for(let i=0;i<PARTICLE_COUNT;i++){
  const r = RADIUS*Math.cbrt(Math.random());
  const theta = Math.acos(2*Math.random()-1);
  const phi = Math.random()*2*Math.PI;
  const x = r*Math.sin(theta)*Math.cos(phi);
  const y = r*Math.sin(theta)*Math.sin(phi);
  const z = r*Math.cos(theta);
  positions.set([x,y,z],i*3);
  basePositions.set([x,y,z],i*3);
  velocities.set([(Math.random()-0.5)*BASE_SPEED,(Math.random()-0.5)*BASE_SPEED,(Math.random()-0.5)*BASE_SPEED],i*3);
}

const partGeo = new THREE.BufferGeometry();
partGeo.setAttribute("position", new THREE.BufferAttribute(positions,3));
const partMat = new THREE.PointsMaterial({ color:0x00ffff, size:0.045, transparent:true, opacity:0.9, blending:THREE.AdditiveBlending });
const points = new THREE.Points(partGeo, partMat);
scene.add(points);

/* === МЫШЬ === */
let mouse = new THREE.Vector2();
let mouseWorld = new THREE.Vector3();
const raycaster = new THREE.Raycaster();
const plane = new THREE.Plane(new THREE.Vector3(0,0,1),0);

document.addEventListener("mousemove",(e)=>{
  mouse.x = (e.clientX/innerWidth)*2-1;
  mouse.y = -(e.clientY/innerHeight)*2+1;
});

/* === АНИМАЦИЯ === */
const clock = new THREE.Clock();

function animate(){
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();

  raycaster.setFromCamera(mouse,camera);
  raycaster.ray.intersectPlane(plane,mouseWorld);

  grid.rotation.y += 0.001;
  earth.rotation.y += 0.0012;
  points.rotation.y += 0.0015;

  for(let i=0;i<PARTICLE_COUNT;i++){
    const idx = i*3;
    const pos = new THREE.Vector3(positions[idx],positions[idx+1],positions[idx+2]);
    const base = new THREE.Vector3(basePositions[idx],basePositions[idx+1],basePositions[idx+2]);

    const jitter = new THREE.Vector3(
      Math.sin(t*1.5+i*0.73)*JITTER_STRENGTH,
      Math.cos(t*1.3+i*0.61)*JITTER_STRENGTH,
      Math.sin(t*1.7+i*0.49)*JITTER_STRENGTH
    );
    pos.add(jitter);

    const dirToMouse = mouseWorld.clone().sub(pos);
    const dist = dirToMouse.length();

    if(dist<RADIUS*1.5){
      const strength = (1-dist/(RADIUS*1.5))*MOUSE_FORCE;
      velocities[idx] += dirToMouse.x*strength;
      velocities[idx+1] += dirToMouse.y*strength;
      velocities[idx+2] += dirToMouse.z*strength;
    }

    const toBase = base.clone().sub(pos).multiplyScalar(RETURN_FORCE);
    velocities[idx] += toBase.x;
    velocities[idx+1] += toBase.y;
    velocities[idx+2] += toBase.z;

    velocities[idx]*=DAMPING;
    velocities[idx+1]*=DAMPING;
    velocities[idx+2]*=DAMPING;

    positions[idx]+=velocities[idx];
    positions[idx+1]+=velocities[idx+1];
    positions[idx+2]+=velocities[idx+2];
  }

  partGeo.attributes.position.needsUpdate = true;
  renderer.render(scene,camera);
}
animate();

/* === АДАПТАЦИЯ === */
window.addEventListener("resize",()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>

